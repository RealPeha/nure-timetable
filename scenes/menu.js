const Scene    = require('telegraf/scenes/base'),
      Keyboard = require('../utils/keyboard'),
      User     = require('../utils/user'),
      Schedule = require('../utils/schedule'),
      Fun      = require('../utils/forfun'),
      Markup   = require('telegraf/markup'),
      Router   = require('telegraf/router'),
      moment   = require('moment')

async function loadSchedule(user, group) {
    const oneDay = await Schedule.getScheduleDay(group/*user.group_id*/, user.current_day)
    let schedule = `<b>${user.current_week.start} - ${user.current_week.end}</b>\n\n<b>${(oneDay.titleFull || '–í–æ—Å–∫—Ä–µ—Å–µ–Ω—å–µ')} - ${user.current_day}</b>\n\n`
    const lessons = oneDay.lessons
    if (lessons.length == 0 && !oneDay.err) {
        //schedule += `<i>–í —ç—Ç–æ—Ç –¥–µ–Ω—å –ø–∞—Ä –Ω–µ—Ç, –æ—Ç–¥—ã—Ö–∞–π—Ç–µ</i>`
        schedule += `<i>${Fun.free()}</i>`
    } else if (oneDay.err) {
        schedule += `<i>${oneDay.err}</i>`
    }
    for (let i = 0; i < lessons.length; i++) {
        schedule += `‚è∞ <i>${lessons[i].start} - ${lessons[i].end}</i>\n<b>üìñ –ü—Ä–µ–¥–º–µ—Ç:</b> ${lessons[i].subject} (<i>${lessons[i].type}</i>)\n`
        //schedule += `<b>üìö</b> ${lessons[i].type}\n`
        if (lessons[i].teacher != false) {
            schedule += `<b>ü§ì –ü—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å:</b> ${lessons[i].teacher}\n`
        }
        if (lessons[i].auditory_name != false) {
            schedule += `<b>üö™ –ê—É–¥–∏—Ç–æ—Ä–∏—è:</b> ${lessons[i].auditory_name}\n`
        }
        schedule += `\n`
    }
    return schedule
}

const calendar = new Router(({ callbackQuery }) => {
    if (!callbackQuery.data) {
        return
    }
    const parts = callbackQuery.data.split(':')
    return {
        route: parts[0],
        state: {
            day: parseInt(parts[1], 10) || 0,
            group: parts[2]
        }
    }
})

calendar.on('day', async (ctx) => {
    const user = ctx.session.user,
          id   = ctx.update.callback_query.from.id,
          week = Schedule.thisWeek(user.current_week.start),
          day  = ctx.state.day,
          group  = ctx.state.group
    if (user.current_day == week[day]) {
        return ctx.answerCbQuery()  
    }
    user.current_day = week[day]
    User.update(id, user)
    const schedule = await loadSchedule(user, group)
    const inlineKeyboard = genInlineKeyboard(group)
    ctx.editMessageText(schedule, inlineKeyboard.extra({parse_mode: 'HTML'}))
    return ctx.answerCbQuery()  
})

calendar.on('week', async (ctx) => {
    const user = ctx.session.user,
          id   = ctx.update.callback_query.from.id,
          week  = ctx.state.day,
          group  = ctx.state.group
    
    if (week > 0) {
        const next = nextWeek(user.current_week.start)
        user.current_week = {
            start: next.start,
            end: next.end
        }
        user.current_day = user.current_week.start
    } else {
        const prev = prevWeek(user.current_week.start)
        user.current_week = {
            start: prev.start,
            end: prev.end
        }
        user.current_day = user.current_week.end
    }
    User.update(id, user)
    const schedule = await loadSchedule(user, group)
    const inlineKeyboard = genInlineKeyboard(group)
    ctx.editMessageText(schedule, inlineKeyboard.extra({parse_mode: 'HTML'}))
    return ctx.answerCbQuery()
})
const nextWeek = (current_week) => {
    const now = moment(current_week, 'DD.MM.YYYY')
    const nextWeek = now.endOf('isoWeek').add(1, 'days')
    //console.log(now, nextWeek)
    return {start: nextWeek.format('DD.MM.YYYY'), end: nextWeek.endOf('isoWeek').add(-2, 'days').format('DD.MM.YYYY')}
}
const prevWeek = (current_week) => {
    const now = moment(current_week, 'DD.MM.YYYY')
    const nextWeek = now.add(-1, 'days').startOf('isoWeek')
    return {start: nextWeek.format('DD.MM.YYYY'), end: nextWeek.endOf('isoWeek').add(-2, 'days').format('DD.MM.YYYY')}
}

calendar.on('today', async (ctx) => {
    const user = ctx.session.user,
          id   = ctx.update.callback_query.from.id,
          day  = ctx.state.day,
          group  = ctx.state.group
    const now = moment()
    const next = now.add(day, 'days')
    const nextDay = next.format('DD.MM.YYYY')
    if (user.current_day == nextDay) {
        return ctx.answerCbQuery()
    }
    user.current_day = nextDay
    user.current_week = {
        start: next.startOf('isoWeek').format('DD.MM.YYYY'),
        end: next.endOf('isoWeek').format('DD.MM.YYYY')
    }
    User.update(id, user)
    const schedule = await loadSchedule(user, group)
    const inlineKeyboard = genInlineKeyboard(group)
    ctx.editMessageText(schedule, inlineKeyboard.extra({parse_mode: 'HTML'}))
    return ctx.answerCbQuery()
})

function genInlineKeyboard(group) {
    return Markup.inlineKeyboard([
        [
            Markup.callbackButton('–°–µ–≥–æ–¥–Ω—è', 'today:0:'+group),
            Markup.callbackButton('–ù–∞ –∑–∞–≤—Ç—Ä–∞', 'today:1:'+group),
        ],
        [
            Markup.callbackButton('–ü–Ω', 'day:0:'+group),
            Markup.callbackButton('–í—Ç', 'day:1:'+group),
            Markup.callbackButton('–°—Ä', 'day:2:'+group),
            Markup.callbackButton('–ß—Ç', 'day:3:'+group),
            Markup.callbackButton('–ü—Ç', 'day:4:'+group),
            Markup.callbackButton('–°–±', 'day:5:'+group)
        ],
        [
            Markup.callbackButton('–ü—Ä–µ–¥—ã–¥—É—â–∞—è –Ω–µ–¥–µ–ª—è', 'week:-1:'+group),
            Markup.callbackButton('–°–ª–µ–¥—É—é—â–∞—è –Ω–µ–¥–µ–ª—è', 'week:1:'+group),
        ]
    ])
}

module.exports = new Scene('menu')
.enter(async (ctx) => {
    const user = ctx.session.user
    if (!user.group.length) {
        //await ctx.reply('–î–ª—è –Ω–∞—á–∞–ª–∞ –≤–∞–º –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –≤—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É', Keyboard.new(['–í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É', '–ù–∞—Å—Ç—Ä–æ–π–∫–∏']).draw())
        ctx.scene.enter('select')
    } else {
        let groups = user.group
        for (let i = 0; i < groups.length; i++) {
            const schedule = await loadSchedule(user, groups[i])
            await ctx.replyWithHTML(`üóì –†–∞—Å–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –≥—Ä—É–ø–ø—ã <b>${groups[i]}</b>`, Keyboard.new(['–ù–∞—Å—Ç—Ä–æ–π–∫–∏', '–ü–æ–º–æ—â—å']).draw())
            const inlineKeyboard = genInlineKeyboard(groups[i])
            await ctx.replyWithHTML(schedule, inlineKeyboard.extra({parse_mode: 'HTML'}))
        }
    }
})
.hears('–ù–∞—Å—Ç—Ä–æ–π–∫–∏', ({ scene }) => {
    scene.enter('settings')
})
.hears('–ü–æ–º–æ—â—å', ({ reply }) => {
    reply('–ï—Å–ª–∏ –±–æ—Ç –ø–µ—Ä–µ—Å—Ç–∞–ª —Ä–µ–∞–≥–∏—Ä–æ–≤–∞—Ç—å –Ω–∞ –≤–∞—à–∏ –∫–æ–º–∞–Ω–¥—ã, –ø—Ä–æ—Å—Ç–æ –ø–æ–≤—Ç–æ—Ä–Ω–æ –≤–≤–µ–¥–∏ –∫–æ–º–∞–Ω–¥—É /start, —á—Ç–æ–±—ã –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –µ–≥–æ.\n\n–°–µ–π—á–∞—Å –±–æ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ä–∞–±–æ—á–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏, –Ω–æ –µ—Å–ª–∏ –≤–∞—Å –∑–∞–∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç, —Ç–æ –≤ –ø–ª–∞–Ω–∞—Ö –¥–æ–±–∞–≤–∏—Ç—å –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –ø–∞—Ä–æ–π (–ª–∏–±–æ –Ω–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è) –≤ —Å—Ç–∏–ª–µ "–ß–µ—Ä–µ–∑ 10 –º–∏–Ω—É—Ç –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ç–∞–∫–∞—è-—Ç–æ –ø–∞—Ä–∞"\n\n–ê –≤–æ–æ–±—â–µ –µ—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å –∫–∞–∫–∏–µ-–ª–∏–±–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è –∏–ª–∏ –≤–æ–ø—Ä–æ—Å—ã, —Ç–æ –ø–∏—à–∏—Ç–µ –º–Ω–µ @RealPeha')
})
.hears('–í—ã–±—Ä–∞—Ç—å –≥—Ä—É–ø–ø—É', ({ scene }) => {
    scene.enter('select')
})
.hears(/\/send ([\s\S]*)/i, async (ctx) => {
    if (ctx.message.from.id == 155054210) {
        const text = ctx.match[1]
        const users = await User.all()
        send(ctx.telegram, users, 0, text)
    } else {
        console.log('permission denied')
    }
})
.on('callback_query', calendar)

function send(telegram, users, i, text) {
    setTimeout(() => {
        if (users[i]) {
            telegram.sendMessage(users[i].id, text)
            .then(() => send(telegram, users, i+1, text))
            .catch(err => {})
        }
    }, 100)
}